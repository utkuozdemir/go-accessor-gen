package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	var sources []string
	flag.Func("source", "Go source file(s) to process", func(s string) error {
		sources = append(sources, s)
		return nil
	})
	suffix := flag.String("suffix", ".generated.go", "Suffix for generated files")
	flag.Parse()

	if err := Run(sources, *suffix); err != nil {
		log.Fatal(err)
	}
}

func Run(sources []string, suffix string) error {
	if len(sources) == 0 {
		return fmt.Errorf("no sources provided, use --source flag")
	}

	for _, source := range sources {
		if err := processFile(source, suffix); err != nil {
			return fmt.Errorf("failed to process file %s: %w", source, err)
		}
	}

	return nil
}

func processFile(filename string, suffix string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse file: %w", err)
	}

	var buf bytes.Buffer
	packageName := node.Name.Name
	buf.WriteString(fmt.Sprintf("// Code generated by go-accessor-gen. DO NOT EDIT.\n"))
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Import needed if we use it, but for basic types we might not need extra imports
	// However, if the field type uses other packages, we might need to handle imports.
	// For this task, let's assume simple types or types already available.
	// Actually, if the original file imports "time", and we generate *time.Duration,
	// we need "time" in the generated file too.
	// A simple approach is to copy all imports from the original file.
	// But that might lead to unused imports.
	// Let's refine the requirement: "reflectively visit all structs... ONLY IF the field is a pointer TO something".
	// The generated code is in the same package (same folder).
	// So we don't need to import the package itself.
	// But we might need external imports used by the fields.
	// For now, let's try to just generate the methods and see.
	// If we need imports, we might need a more complex import resolution or just copy all imports.
	// Let's inspect the imports of the source file and copy them for safety?
	// Or better, let's just generate the code and rely on `goimports` to fix it (if the user has it)?
	// The prompt doesn't say we can rely on external tools.
	// Let's try to copy imports from the node.

	if len(node.Imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range node.Imports {
			if imp.Name != nil {
				buf.WriteString(fmt.Sprintf("\t%s %s\n", imp.Name.Name, imp.Path.Value))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s\n", imp.Path.Value))
			}
		}
		buf.WriteString(")\n\n")
	}

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structName := typeSpec.Name.Name

			for _, field := range structType.Fields.List {
				// field.Type is the type AST. We want to check if it's a pointer.
				starExpr, ok := field.Type.(*ast.StarExpr)
				if !ok {
					continue
				}

				// It is a pointer. Check if it points to a pointer (which we should exclude?)
				// Requirement: "NOT pointer types, like []string or map."
				// Wait, []string is a slice, not a pointer type in AST (it's ArrayType).
				// map is MapType.
				// *[]string is StarExpr -> ArrayType. This IS allowed per "for example... *[]string".
				// Requirement: "NOT pointer types, like []string or map"
				// This likely means: Don't generate for non-pointer fields like `F []string`.
				// Only generate for `F *[]string` or `F *string`.
				// So if it IS a StarExpr, we are good?
				// "the field is a pointer TO something... NOT pointer types, like []string or map."
				// This phrasing clarifies: We only want fields that are explicitly `*T`.
				// We do NOT want fields that are implicitly reference types but not pointers, like `map[string]int` or `[]int`.
				// Since we checked `field.Type.(*ast.StarExpr)`, we are strictly looking at `*...`.
				// So `*[]string` is fine. `[]string` is not.

				// Now we need the type name as string to use in generation.
				// We can use a printer to print the expression `starExpr.X`.

				var typeBuf bytes.Buffer
				if err := printer.Fprint(&typeBuf, fset, starExpr.X); err != nil {
					return fmt.Errorf("failed to print type: %w", err)
				}
				valueType := typeBuf.String()

				// Field names. A field line can have multiple names: `A, B *int`
				for _, name := range field.Names {
					fieldName := name.Name

					// Getter
					// func (s *Struct) FieldName() Type
					buf.WriteString(fmt.Sprintf("func (s *%s) Get%s() %s {\n", structName, fieldName, valueType))
					buf.WriteString(fmt.Sprintf("\tif s == nil || s.%s == nil {\n", fieldName))
					buf.WriteString(fmt.Sprintf("\t\treturn *new(%s)\n", valueType)) // Zero value
					buf.WriteString("\t}\n")
					buf.WriteString(fmt.Sprintf("\treturn *s.%s\n", fieldName))
					buf.WriteString("}\n\n")

					// Setter
					// func (s *Struct) SetFieldName(v Type)
					buf.WriteString(fmt.Sprintf("func (s *%s) Set%s(v %s) {\n", structName, fieldName, valueType))
					// If s is nil? method value receiver would panic anyway if called on nil interface,
					// but pointer receiver allows nil.
					// If s is nil, we can't set. Panic is standard Go behavior for nil pointer dereference.
					// But let's check safety. "The getters and setters should be safe for nil pointers."
					// "If the pointer is nil, return the zero value..." (Getter).
					// For setter, if s is nil, we probably should panic or do nothing?
					// Standard setters usually panic on nil struct.
					// However, if we want to be "safe", maybe we do nothing?
					// But the prompt says "setter would accept string, not *string".
					// It doesn't explicitly say what to do if the struct itself is nil for SETTER only for GETTER.
					// Let's assume standard behavior for setter (panic if struct is nil) OR check?
					// Let's just do `s.Field = &v`.
					buf.WriteString(fmt.Sprintf("\ts.%s = &v\n", fieldName))
					buf.WriteString("}\n\n")
				}
			}
		}
	}

	// Write to file
	originalExt := filepath.Ext(filename)
	base := strings.TrimSuffix(filename, originalExt)
	outFilename := base + suffix
	if err := os.WriteFile(outFilename, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", outFilename, err)
	}

	return nil
}
